"""
Basic malware scanning for uploaded files
"""
import os
import hashlib
import magic
import logging
from typing import Dict, Tuple, Optional

logger = logging.getLogger(__name__)

class MalwareScanner:
    """Basic malware scanner for uploaded files"""

    MALICIOUS_HASHES = set([
        "d41d8cd98f00b204e9800998ecf8427e",
    ])

    BLOCKED_EXTENSIONS = {
        '.exe', '.dll', '.bat', '.cmd', '.com', '.scr', '.pif',
        '.vbs', '.js', '.jar', '.msi', '.app', '.deb', '.rpm',
        '.sh', '.run', '.apk', '.ipa'
    }

    ALLOWED_MIME_TYPES = {
        'application/pdf',
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'application/msword',
        'text/plain',
        'application/octet-stream'
    }

    def __init__(self):
        """Initialize malware scanner"""
        self.magic_available = self._check_magic()

    def _check_magic(self) -> bool:
        """Check if python-magic is available"""
        try:
            magic.Magic()
            return True
        except Exception:
            logger.warning("python-magic not available, MIME type checking disabled")
            return False

    def calculate_file_hash(self, file_path: str) -> str:
        """Calculate MD5 hash of file"""
        try:
            hash_md5 = hashlib.md5()
            with open(file_path, "rb") as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    hash_md5.update(chunk)
            return hash_md5.hexdigest()
        except Exception as e:
            logger.error(f"Error calculating file hash: {e}")
            return ""

    def check_file_extension(self, filename: str) -> Tuple[bool, str]:
        """
        Check if file extension is allowed

        Returns:
            (is_safe, message)
        """
        _, ext = os.path.splitext(filename.lower())

        if ext in self.BLOCKED_EXTENSIONS:
            return False, f"Blocked file extension: {ext}. This file type is not allowed."

        return True, "File extension is allowed"

    def check_mime_type(self, file_path: str) -> Tuple[bool, str]:
        """
        Check if MIME type is allowed

        Returns:
            (is_safe, message)
        """
        if not self.magic_available:
            return True, "MIME type check skipped (python-magic not available)"

        try:
            mime = magic.Magic(mime=True)
            file_type = mime.from_file(file_path)

            if file_type in self.ALLOWED_MIME_TYPES:
                return True, f"MIME type allowed: {file_type}"

            if any(allowed in file_type for allowed in ['pdf', 'word', 'text', 'document']):
                return True, f"MIME type allowed (variant): {file_type}"

            return False, f"Suspicious MIME type: {file_type}"

        except Exception as e:
            logger.error(f"Error checking MIME type: {e}")
            return True, "MIME type check failed (allowed by default)"

    def check_file_hash(self, file_path: str) -> Tuple[bool, str]:
        """
        Check file hash against known malware database

        Returns:
            (is_safe, message)
        """
        file_hash = self.calculate_file_hash(file_path)

        if file_hash in self.MALICIOUS_HASHES:
            return False, f"File matches known malware signature: {file_hash}"

        return True, "File hash clean"

    def check_file_size(self, file_path: str, max_size_mb: int = 10) -> Tuple[bool, str]:
        """
        Check if file size is within limits

        Returns:
            (is_safe, message)
        """
        try:
            file_size = os.path.getsize(file_path)
            max_size_bytes = max_size_mb * 1024 * 1024

            if file_size > max_size_bytes:
                return False, f"File too large: {file_size / (1024 * 1024):.2f}MB (max: {max_size_mb}MB)"

            if file_size == 0:
                return False, "File is empty"

            return True, f"File size OK: {file_size / 1024:.2f}KB"

        except Exception as e:
            logger.error(f"Error checking file size: {e}")
            return False, f"Error checking file size: {str(e)}"

    def check_embedded_executables(self, file_path: str) -> Tuple[bool, str]:
        """
        Check for embedded executables in documents (basic check)

        Returns:
            (is_safe, message)
        """
        try:
            with open(file_path, 'rb') as f:
                content = f.read(1024 * 1024)

                suspicious_patterns = [
                    b'MZ',
                    b'\x7fELF',
                    b'\xfe\xed\xfa',
                ]

                for pattern in suspicious_patterns:
                    if pattern in content:
                        return False, f"Suspicious embedded executable detected"

                return True, "No embedded executables detected"

        except Exception as e:
            logger.error(f"Error checking for embedded executables: {e}")
            return True, "Embedded executable check failed (allowed by default)"

    def scan_file(self, file_path: str, filename: str, max_size_mb: int = 10) -> Dict[str, any]:
        """
        Comprehensive file scan

        Args:
            file_path: Path to file to scan
            filename: Original filename
            max_size_mb: Maximum file size in MB

        Returns:
            {
                'is_safe': bool,
                'threats_found': list,
                'warnings': list,
                'checks_passed': dict
            }
        """
        threats = []
        warnings = []
        checks = {}

        is_safe, message = self.check_file_extension(filename)
        checks['extension'] = {'passed': is_safe, 'message': message}
        if not is_safe:
            threats.append(message)

        is_safe, message = self.check_file_size(file_path, max_size_mb)
        checks['file_size'] = {'passed': is_safe, 'message': message}
        if not is_safe:
            threats.append(message)

        is_safe, message = self.check_mime_type(file_path)
        checks['mime_type'] = {'passed': is_safe, 'message': message}
        if not is_safe:
            warnings.append(message)

        is_safe, message = self.check_file_hash(file_path)
        checks['file_hash'] = {'passed': is_safe, 'message': message}
        if not is_safe:
            threats.append(message)

        is_safe, message = self.check_embedded_executables(file_path)
        checks['embedded_executables'] = {'passed': is_safe, 'message': message}
        if not is_safe:
            threats.append(message)

        is_file_safe = len(threats) == 0

        return {
            'is_safe': is_file_safe,
            'threats_found': threats,
            'warnings': warnings,
            'checks_passed': checks,
            'scan_summary': f"{'CLEAN' if is_file_safe else 'THREAT DETECTED'} - {len(threats)} threats, {len(warnings)} warnings"
        }

_malware_scanner_instance = None

def get_malware_scanner() -> MalwareScanner:
    """Get or create malware scanner instance (singleton)"""
    global _malware_scanner_instance
    if _malware_scanner_instance is None:
        _malware_scanner_instance = MalwareScanner()
    return _malware_scanner_instance

